# RFC: Server Side Rendering

## Status

- Start Date: 2019-02-10
- RFC PR: https://github.com/salesforce/lwc/pull/1048

## Summary

This RFC defines the infrastructure pieces for the various platforms running LWC to be able to do server side rendering (SSR) without explicit coordination with components' authors.

## Motivation

The motivation for SSR is not a question at this point, we need it, every popular framework provides the full infrastructure or the pieces necessarily for consumers of the framework to implement their own mechanism. This is critical for LWC due to the performance characteristics of SSR for salesforce various platforms.

## Goals of this proposal

- Define how a developer can render component to a string value in a non-browser environment.
- Define how a developer can suspend the rendering of a component at will in order to wait for the data to be ready.
- Define how a developer can control timeout, retry and fallback for wire adapters.
- Define how LWC engine can upgrade html content generated by LWC in a different platform (e.g.: server).
- Define features of LWC that will work, or not, in a non-browser environment.

## Proposals

To support rendering a component, and all sub-components to string, we need to keep in mind that the shadow boundaries must be preserved, so when the markup is reconciliated with the runtime version of the same component instance on the client side, the diffing algorism can preserve as much Nodes as possible to avoid the annoying flickering.

Other libraries do not have this problem, since they don't rely on the shadow dom semantics to be begin with. What this really means is that the produced string will have to have special annotations to be able to distinguish between the markup produced by the different components. It is important to notice that this could change in the future if browsers implement a declarative way to define a headless shadow dom, and this is actually our first new invariant:

* To provide SSR capabilities, LWC must run with synthetic shadow dom enabled on both ends, server side and client side.

As a derived invariant, since synthetic shadow dom does not support a root element to have slotted content, we can also enforce the following:

* To render a component to string, LWC must not allow the root element to have allocated content on both ends, server side and client side.

In order to produce a string representation of a root component and its sub-components (from its shadow), we need to to focus on two main things:

a) how can a user generate an HTML fragment that represents the state of a component and its sub-components in a way that it can be upgraded on the client side?

b) how can a user bend the rules of the engine by disabling certain hooks?

It is very likely that both things can be done in user-land without any especial API provided by LWC, and instead we could just prepare the server side environment to look like a regular LWC environment, but wrapping all public API to achieve both. More details about this to come.

The second topic to discuss on this proposal is the "sync" nature of the engine today. When a component is inserted into the DOM, the component renders, and all sub-components are subsequently as well in a synchronous manner, while components who are in need for data, might re-render themselves by virtue of a mutation in a later tick. This will not work on the server side because we need a time-frame where the fragment is ready, and later mutations of the DOM structure is not possible. This means we need a way to suspend the rendering process until we have the data available to continue filling the blanks during the first rendering process rather than a secondary process.

The suspend protocol can be baked into the wire protocol initially, a wire adapter can signal to suspense the component's rendering mechanism (via a `SuspenseEvent`), to force the component to wait until the data is available to render the first time. This is possible due to an existing invariant: LWC Engine has the discretion to render the component at will when necessary. This could be used to define a new invariant:

* A wire adapter can suspend the upcoming rendering cycle until a later turn by dispatching the `SuspenseEvent` onto the wire `eventTarget`.

This will work very well on the server side where the component author doesn't interact with the DOM (it is not a real DOM anyways). The engine will just wait until the adapter issue the `ResumeEvent` to unlock the rendering cycle for the component, ultimately produce the final HTML.

Another piece of the puzzle is about the "upgrading" of the markup produced by the server side. First of all, we are overloading the term "rehydration", we already use it to denote the secondary rendering cycle, which should probably be called just "re-rendering". From now on, we can call "upgrade" to the process of getting some markup (generated by someone), and rendering an LWC on top of that by reusing as much as possible from the original DOM structure, and we can call "rendering" and "re-rendering" to the process of updating the `shadowRoot` of an LWC.

Based on this assumption, the markup generated by the server side should be reused by LWC engine when possible, the question is: how?

In principle, the only mechanism to communicate from the server to the LWC engine running on the client is the DOM markup, based on this assumption, the engine should be able to read the markup structure, attributes, and extra annotations in form of especial attribute to try to build the in-memory representation of the VNodes before applying the regular diffing mechanism.

There are several considerations:

 * We need to mark (via an attribute) custom elements generated by LWC
 * We need to mark (via an attribute) which shadowRoot a particular element belongs to
    - How to do the same for non-elements, eg.: Text Nodes or Comments.

Once we know a host element should be "upgraded", our diffing algorithm can take the necessary steps to build the virtual tree (this is equivalent to Snabbdom `toVNode` API, which we have removed from LWC because it didn't include the shadow boundaries detection).

Last, but not least, we need to be able to disable certain features when executing on certain environments, for example, on the server side there is no user-interaction, so, adding event listeners to the DOM is useless, or attempting to re-render due to a mutation is not useful, we should never re-render a component on the server side, only the first output is useful.

Another observable difference with respect to what we do on the client side today is that some hooks should never be invoked, e.g.: `errorCallback`, `connectedCallback`, `disconnectedCallback` and `renderedCallback`, because they offer access to the content of the `shadowRoot`, which on the server side makes no sense to interact with.

At first glance, offering the ability to replace `LightningElement` with something equivalent that has less capabilities in very interesting, but it is not sufficient because the super doesn't have the capabilities to prevent hooks to be inspected by the engine. This means that we will have to provide an alternative mechanism to disable such hooks.

## Detailed Design

### Proposal: RenderToString

The new package `@lwc/ssr` could provide such functionality by just wrapping the `createElement` API, the `LightningElement` abstraction, and adding a new `RenderToString` API to extract the innerHTML, and returning it, no changes are necessary on LWC to enable this, other than a way to disable certain features. More details about that in another section below. Here is an example of how to render a component to string:

```js
import { createElement, RenderToString } from '@lwc/ssr';
import Todo from 'todo-mvc';
const elm = createElement(Todo, { is: Todo });
elm.foo = 1;
elm.bar = 'something';
const html = RenderToString(elm);
```

Open Questions:

* Can this be really done in user-land?

### Proposal: Suspense Rendering API

The suspend protocol can be baked into the wire protocol initially, so a wire adapter can signal to suspense the component's rendering mechanism (via the `SuspenseEvent`), to force the component to wait until the data
is available to render the first time. 

```js
import { register, SuspenseEvent } from 'wire-service';
register(getTodo, function getTodoWireAdapterFactory(eventTarget) {
    let config;

    eventTarget.addListener('config', (newConfig) => {
        if (config === undefined) {
            // this will force the component to wait until the data is set via ValueChangedEvent
            eventTarget.dispatchEvent(new SuspenseEvent());
        }
        config = newConfig;
    });

    // ....
});
```

Of course, this new feature not only enable the `SuspenseEvent` to be used on the server side, but anywhere else where the adapter decides to rely on it, it could also be configured by the consumer of the adapter somehow, this seems to be very flexible to begin with.

A potential problem here is that by using a particular adapter, the component author will have to protect itself, making the component a lot more defensive because public API calls, and connected callback are not longer enough signal to determine whether or not the shadow was already populated with the selected template. Something to keep in mind.

Open Questions:

* How is in control of the suspense configuration? the global configuration? the component author? the adapter author?

### Proposal: WireAdapter Configuration (and default configuration)

These has two folds, a) how a wire adapter can be configured in a way that the user has more control over the wire flow, and b) how a wire adapter can have more control over the component?

```js
import { LightningElement, wire } from '@lwc';
import { getTodo, refreshTodo } from 'todo-wire-adapter';
export default class TodoViewer extends LightningElement {
    @api id;
    // Wire identifier is the imported callable getTodo
    @wire(getTodo, { id: '$id' }, {
        timeout: 1000, // should default to 1 second
        attemptToRefresh: 36000, // in ms, should default to 0
    })
    wiredTodo;
}
```

The high-order bit here is how an adapter can be tailor-made for a particular environment, (e.g.: server side) while defining the default configuration for that medium, while still accepting certain configurations from users.

The actual problem here is how to keep all adapters in sync with it comes to implement these configurations. Passing the configuration to the adapter, and letting the adapter to do the right thing will not fit the bill here, it is way to easy to mess up, and users have no way to make a determination of who is at fault. For those reasons, expending the wire protocol to notify adapters when a timeout has occur, or when the data should be re-fetched is easier and safer. E.g.:

```js
function getTodoWireAdapterFactory(eventTarget) {
    let subscription;
    let config;

    eventTarget.addListener('timeout', (config) => {
        // the adapter receives a report that a timeout was issue by the component
        // due to inactivity
    });

    eventTarget.addListener('refresh', (config) => {
        // the adapter receives a report that a component will like to refresh
        // the wired data if possible
    });

    // ...

}
```

As for the default configuration, I think the APP owner should have the control. And alternative here is to use the `LWC_config` global variable to have a section about the wire, e.g.:

```js
LWC_config = {
    synthetic: true,
    wire: {
        suspense: 'always', // defaults to "never"
        timeout: 300,
    },
};
```

On the server side, you might want to suspense the wire call every time, forcing all components to render once the data has arrived, or timeout if the request takes more than 300 ms.

Note: `timeout` and `attemptToRefresh` are not needed as a configuration option per adapter instance when wiring it, that could come later. Same for the suspense configuration, we could support that only via the global config to begin with.

### Proposal: Rehydrate from markup

This is the proposed API:

```js
import { upgradeElement } from '@lwc';
import Todo from 'todo-mvc';
const elm = document.querySelector('x-todo');
upgradeElement(elm, { is: Todo });
elm.foo = 1;
elm.bar = 'something';
```

In the example above, the new `upgradeElement` API is going to upgrade `elm` reference in the next tick to give you time to reconciliate the initial state, if any, but also to match the semantics of the Web Components API where the upgrade happens on the next tick after the new tagName is registered. At this point, the `elm`'s content will be inspected to extract the current state of the DOM from it to try to prepare the VM and its VNodes for the upcoming rendering cycle that will try to preserve as much as possible from the existing DOM structure based on the annotations.

The biggest challenge here seems to be the allocation of Text Nodes, but we might be able to mark them somehow, maybe via a comment with some flags on it. Additionally, having multiple sibling Text Nodes is cumbersome, but in that case we can treat them all as one, and let the diffing algorithm to readjust it by inserting the new nodes, and updating their text, which should not have any impact whatsoever in the user-experience. But if we decide to go with the comments, that might work better since we can mark each individual Text Node, and after the diffing algorithm finishes, the comments with the annotations will be completely removed from the DOM since they will not be part of the new VNode Tree. 

### Proposal: Disabled Features for non-browser environment

TBD

## How we teach this ?

TBD