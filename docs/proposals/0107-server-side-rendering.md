# RFC: Server Side Rendering

## Status

- Start Date: 2019-02-10
- RFC PR: https://github.com/salesforce/lwc/pull/

## Summary

This RFC defines the infrastructure pieces for the various platforms running LWC to be able to do server side rendering (SSR) without explicit coordination with components' authors.

## Motivation

The motivation for SSR is not a question at this point, we need it, every popular framework provides the full infrastructure or the pieces necessarily for consumers of the framework to implement their own mechanism. This is critical for LWC due to the performance characteristics of SSR for salesforce various platforms.

## Goals of this proposal

- Define how a developer can render component to a string value in a non-browser environment.
- Define how a developer can suspend the rendering of a component at will in order to wait for the data to be ready.
- Define how a developer can control timeout, retry and fallback for wire adapters.
- Define how LWC engine can rehydrated html content generated by LWC in a different platform (e.g.: server).
- Define features of LWC that will work, or not, in a non-browser environment.

## Proposals

Since this RFC contains various proposal, we will define them individually.

### Proposal: RenderToString

This proposal is mostly focused on two aspects:

a) how can a user generate an HTML fragment that represents the state of a component?

b) how can a user bend the rules of the engine by disabling certain hooks?

It is very likely that both things can be done in user-land without any especial API provided by LWC, e.g.:

```js
import { createElement, RenderToString } from '@lwc/ssr';
import Todo from 'todo-mvc';
const elm = createElement(Todo, { is: Todo });
elm.foo = 1;
elm.bar = 'something';
const html = RenderToString(elm);
```

The new package `@lwc/ssr` could provide such functionality by just wrapping the `createElement` API, the `LightningElement` abstraction, and adding a new `RenderToString` API to extract the innerHTML, and returning it, no changes are necessary on LWC to enable this, other than a way to disable certain features. More details about that in another proposal section below.

#### Open Questions:

* Can this be really done in user-land?

### Proposal: Suspense Rendering API

The suspend protocol can be baked into the wire protocol initially, so a wire adapter can signal to suspense the component's rendering mechanism (via the `SuspenseEvent`), to force the component to wait until the data
is available to render the first time. 

```js
import { register, SuspenseEvent } from 'wire-service';
register(getTodo, function getTodoWireAdapterFactory(eventTarget) {
    let config;

    eventTarget.addListener('config', (newConfig) => {
        if (config === undefined) {
            // this will force the component to wait until the data is set via ValueChangedEvent
            eventTarget.dispatchEvent(new SuspenseEvent());
        }
        config = newConfig;
    });

    // ....
});
```

Of course, this new feature not only enable the `SuspenseEvent` to be used on the server side, but anywhere else where the adapter decides to rely on it, it could also be configured by the consumer of the adapter somehow, this seems to be very flexible to begin with.

A potential problem here is that by using a particular adapter, the component author will have to protect itself, making the component a lot more defensive because public API calls, and connected callback are not longer enough signal to determine whether or not the shadow was already populated with the selected template. Something to keep in mind.

### Proposal: WireAdapter Configuration (and default configuration)

These has two folds, a) how a wire adapter can be configured in a way that the user has more control over the wire flow, and b) how a wire adapter can have more control over the component?

```js
import { LightningElement, wire } from '@lwc';
import { getTodo, refreshTodo } from 'todo-wire-adapter';
export default class TodoViewer extends LightningElement {
    @api id;
    // Wire identifier is the imported callable getTodo
    @wire(getTodo, { id: '$id' }, {
        timeout: 1000, // should default to 1 second
        attemptToRefresh: 36000, // in ms, should default to 0
    })
    wiredTodo;
}
```

The high-order bit here is how an adapter can be tailor-made for a particular environment, (e.g.: server side) while defining the default configuration for that medium, while still accepting certain configurations from users.

The actual problem here is how to keep all adapters in sync with it comes to implement these configurations. Passing the configuration to the adapter, and letting the adapter to do the right thing will not fit the bill here, it is way to easy to mess up, and users have no way to make a determination of who is at fault. For those reasons, expending the wire protocol to notify adapters when a timeout has occur, or when the data should be re-fetched is easier and safer. E.g.:

```js
function getTodoWireAdapterFactory(eventTarget) {
    let subscription;
    let config;

    eventTarget.addListener('timeout', (config) => {
        // the adapter receives a report that a timeout was issue by the component
        // due to inactivity
    });

    eventTarget.addListener('refresh', (config) => {
        // the adapter receives a report that a component will like to refresh
        // the wired data if possible
    });

    // ...

}
```

As for the default configuration, I think the APP owner should have the control. And alternative here is to use the `LWC_config` global variable to have a section about the wire, e.g.:

```js
LWC_config = {
    synthetic: true,
    wire: {
        suspense: 'always', // defaults to "never"
        timeout: 300,
    },
};
```

On the server side, you might want to suspense the wire call every time, forcing all components to render once the data has arrived, or timeout if the request takes more than 300 ms.

### Proposal: Rehydrate from markup

First of all, we are overloading the term "rehydration", we already use it to denote the secondary rendering cycle, which should probably be called just "re-rendering". From now on, we can call "rehydration" to the process of getting some markup (generated by someone), and rendering an LWC on top of that by reusing as much as possible from the original DOM structure, and we can call "rendering" and "re-rendering" to the process of updating the `shadowRoot` of an LWC.

Based on this assumption, the markup generated by the server side should be reused by LWC engine when possible, the question is, how so?

In principle, the only mechanism to communicate from the server to the LWC engine running on the client is the DOM markup, based on this assumption, we could add a flag (attribute) into the markup (when produced by SSR), and use that flag as a mechanism to run the engine diffing algorithm' rehydrate routine, which will be responsible for ingesting the current markup to try to build the in-memory representation of the VNodes before applying the regular patching mechanism.

There are several considerations:

 * We need to mark (via an attribute) custom elements generated by LWC
 * We need to mark (via an attribute) to which shadowRoot a particular element belongs to
    - How to do the same for non-elements, eg.: Text Nodes or Comments.

Once we know a host element should be "rehydrated" our diffing algorithm can take the necessary steps to build the virtual tree (this is equivalent to Snabbdom `toVNode` API, which we have removed from LWC because it didn't include the shadow boundaries detection). This is the proposed API:

```js
import { upgradeElement } from '@lwc';
import Todo from 'todo-mvc';
const elm = document.querySelector('x-todo');
upgradeElement(elm, { is: Todo });
elm.foo = 1;
elm.bar = 'something';
```

In the example above, the new `upgradeElement` API is going to upgrade `elm` reference in the next tick to give you time to reconciliate the initial state, if any, but also to match the semantics of the Web Components API where the upgrade happens on the next tick after the new tagName is registered. At this point, the `elm`'s content will be inspected to extract the current state of the DOM from it to try to prepare the VM and its VNodes for the upcoming rendering cycle that will try to preserve as much as possible from the existing DOM structure based on the annotations.

The biggest challenge here seems to be the allocation of Text Nodes, but we might be able to mark them somehow, maybe via a comment with some flags on it. Additionally, having multiple sibling Text Nodes is cumbersome, but in that case we can treat them all as one, and let the diffing algorithm to readjust it by inserting the new nodes, and updating their text, which should not have any impact whatsoever in the user-experience. But if we decide to go with the comments, that might work better since we can mark each individual Text Node, and after the diffing algorithm finishes, the comments with the annotations will be completely removed from the DOM since they will not be part of the new VNode Tree. 

### Proposal: Disabled Features for non-browser environment

Last, but not least, we need to be able to disable certain features when executing on certain environments, for example, on the server side there is no user-interaction, so, adding event listeners to the DOM is useless, or attempting to re-render due to a mutation is not useful, we should never re-render a component on the server side, only the first output is useful.

Another observable difference with respect to what we do on the client side today is that some hooks should never be invoked, e.g.: `errorCallback`, `connectedCallback`, `disconnectedCallback` and `renderedCallback`, because they offer access to the content of the `shadowRoot`, which on the server side makes no sense to interact with.

At first glance, offering the ability to replace `LightningElement` with something equivalent that has less capabilities in very interesting, but it is not sufficient because the super doesn't have the capabilities to prevent hooks to be inspected by the engine. This means that we will have to provide an alternative mechanism to disable such hooks. This is TBD at the moment.
