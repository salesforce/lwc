/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
import { VNodes } from '../3rdparty/snabbdom/types';
import { tagNameGetter } from '../env/element';
import { setPrototypeOf, create, isUndefined, isTrue } from '../shared/language';
import { ComponentDef } from './def';
import { HTMLElementConstructor } from './base-bridge-element';

// TODO: eventually the engine should not do any of this work,
// it should just interact with the DOM, and the polyfill should
// take care of all these operation
import {
    PatchedElement,
    PatchedSlotElement,
    PatchedNode,
    PatchedIframeElement,
    markElementAsPortal,
    setCSSToken,
} from '@lwc/synthetic-shadow';

// Using a WeakMap instead of a WeakSet because this one works in IE11 :(
const FromIteration: WeakMap<VNodes, 1> = new WeakMap();

// dynamic children means it was generated by an iteration
// in a template, and will require a more complex diffing algo.
export function markAsDynamicChildren(children: VNodes) {
    FromIteration.set(children, 1);
}

export function hasDynamicChildren(children: VNodes): boolean {
    return FromIteration.has(children);
}

let TextNodeProto: object;

// this method is supposed to be invoked when in fallback mode only
// to patch text nodes generated by a template.
export function patchTextNodeProto(text: Text) {
    if (isUndefined(TextNodeProto)) {
        TextNodeProto = PatchedNode(text).prototype;
    }
    setPrototypeOf(text, TextNodeProto);
}

let CommentNodeProto: object;

// this method is supposed to be invoked when in fallback mode only
// to patch comment nodes generated by a template.
export function patchCommentNodeProto(comment: Comment) {
    if (isUndefined(CommentNodeProto)) {
        CommentNodeProto = PatchedNode(comment).prototype;
    }
    setPrototypeOf(comment, CommentNodeProto);
}

const TagToProtoCache: Record<string, object> = create(null);

function getPatchedElementClass(elm: HTMLElement): HTMLElementConstructor {
    switch (tagNameGetter.call(elm)) {
        case 'SLOT':
            return PatchedSlotElement(elm as HTMLSlotElement);
        case 'IFRAME':
            return PatchedIframeElement(elm as HTMLIFrameElement);
    }
    return PatchedElement(elm);
}

// this method is supposed to be invoked when in fallback mode only
// to patch elements generated by a template.
export function patchElementProto(
    elm: HTMLElement,
    options: { sel: string; isPortal: boolean; shadowAttribute?: string }
) {
    const { sel, isPortal, shadowAttribute } = options;
    let proto = TagToProtoCache[sel];
    if (isUndefined(proto)) {
        proto = TagToProtoCache[sel] = getPatchedElementClass(elm).prototype;
    }
    setPrototypeOf(elm, proto);
    // TODO: we need another mechanism to mark elements as portal
    if (isTrue(isPortal)) {
        markElementAsPortal(elm);
    }
    // TODO: we need another mechanism to apply css tokens
    setCSSToken(elm, shadowAttribute);
}

// since the proto chain is unique per constructor,
// we can just store it inside the `def`
interface PatchedComponentDef extends ComponentDef {
    patchedBridge?: HTMLElementConstructor;
}

export function patchCustomElementProto(
    elm: HTMLElement,
    options: { def: ComponentDef; shadowAttribute?: string }
) {
    const { def, shadowAttribute } = options;
    let patchedBridge = (def as PatchedComponentDef).patchedBridge;
    if (isUndefined(patchedBridge)) {
        patchedBridge = (def as PatchedComponentDef).patchedBridge = PatchedElement(
            elm
        ) as HTMLElementConstructor;
    }
    // temporary patching the proto, eventually this should be just more nodes in the proto chain
    setPrototypeOf(elm, patchedBridge.prototype);
    setCSSToken(elm, shadowAttribute);
}
