import { VNodes } from "../3rdparty/snabbdom/types";
import { patchEvent } from "../faux-shadow/faux";
import { patchCustomElement } from "../faux-shadow/faux";
import { elementTagNameGetter } from "./dom-api";
import { updateDynamicChildren, updateStaticChildren } from "../3rdparty/snabbdom/snabbdom";
import { setPrototypeOf, getPrototypeOf, create, isUndefined } from "../shared/language";
import { ComponentDef } from "./def";
import { HTMLElementConstructor } from "lwc-engine/src/framework/base-bridge-element";
import { ElementPatchDescriptors, SlotPatchDescriptors, NodePatchDescriptors, IframeDescriptors } from "../faux-shadow/traverse";

// Using a WeakMap instead of a WeakSet because this one works in IE11 :(
const FromIteration: WeakMap<VNodes, 1> = new WeakMap();

// dynamic children means it was generated by an iteration
// in a template, and will require a more complex diffing algo.
export function markAsDynamicChildren(children: VNodes) {
    FromIteration.set(children, 1);
}

export function hasDynamicChildren(children: VNodes): boolean {
    return FromIteration.has(children);
}

export function patchChildren(host: Element, shadowRoot: ShadowRoot, oldCh: VNodes, newCh: VNodes, isFallback: boolean) {
    if (oldCh !== newCh) {
        const parentNode = isFallback ? host : shadowRoot;
        const fn = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;
        fn(parentNode, oldCh, newCh);
    }
}

let TextNodeProto: object;

// this method is supposed to be invoked when in fallback mode only
// to patch text nodes generated by a template.
export function patchTextNodeProto(text: Text) {
    if (isUndefined(TextNodeProto)) {
        TextNodeProto = create(getPrototypeOf(text), NodePatchDescriptors);
    }
    setPrototypeOf(text, TextNodeProto);
}

let CommentNodeProto: object;

// this method is supposed to be invoked when in fallback mode only
// to patch comment nodes generated by a template.
export function patchCommentNodeProto(comment: Comment) {
    if (isUndefined(CommentNodeProto)) {
        CommentNodeProto = getPrototypeOf(comment);
    }
    setPrototypeOf(comment, CommentNodeProto);
}

const TagToProtoCache: Record<string, object> = create(null);

function getPatchedElementPrototypeOf(elm: HTMLElement) {
    let descriptors = ElementPatchDescriptors;
    switch (elementTagNameGetter.call(elm)) {
        case 'SLOT':
            descriptors = SlotPatchDescriptors;
            break;
        case 'IFRAME':
            descriptors = IframeDescriptors;
            break;
    }
    return create(getPrototypeOf(elm), descriptors);
}

// this method is supposed to be invoked when in fallback mode only
// to patch elements generated by a template.
export function patchElementProto(elm: HTMLElement, tag: string) {
    let proto = TagToProtoCache[tag];
    if (isUndefined(proto)) {
        proto = TagToProtoCache[tag] = getPatchedElementPrototypeOf(elm);
    }
    setPrototypeOf(elm, proto);
}

// since the proto chain is unique per constructor,
// we can just store it inside the `def`
interface PatchedComponentDef extends ComponentDef {
    patchedBridge: HTMLElementConstructor;
}

export function patchCustomElementProto(elm: HTMLElement, tag: string, def: ComponentDef) {
    let bridge = (def as PatchedComponentDef).patchedBridge;
    if (isUndefined(bridge)) {
        bridge = (def as PatchedComponentDef).patchedBridge = create(def.bridge.prototype, ElementPatchDescriptors);
    }
    // temporary patching the proto, eventually this should be just more nodes in the proto chain
    patchCustomElement(elm);
    setPrototypeOf(elm, bridge);
}

export {
    patchEvent,
};
